# -*- coding: utf-8 -*-
"""FinalProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R1pxemZSgUTxxlVBZ06YJ_6OQDwyzI0u
"""

from google.colab import drive
drive.mount('/content/drive')
import cv2
import os
os.getcwd()
os.chdir("/content/drive/My Drive/Colab Notebooks/503044/FinalProject")

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

df = pd.read_csv('./dataset/Clean_Dataset.csv')
df.head()

# Print the shape of data
df.shape

# See the duplicated data
df.duplicated().sum()

filtered_data = df[df['flight'].isin(['SG-8709'])]
filtered_data.head()

df=df.drop('Unnamed: 0',axis=1)
df.info()

"""**TIỀN XỬ LÝ DỮ LIỆU**"""

df.describe()

"""**Thông tin chi tiết**
- Phương thức describe() trong Pandas được sử dụng để tạo số liệu thống kê mô tả về DataFrame hoặc một cột cụ thể trong DataFrame, thường dành cho dữ liệu số. Nó cung cấp các số liệu thống kê tóm tắt như số lượng, giá trị trung bình, độ lệch chuẩn, tối thiểu, tối đa và tứ phân vị cho mỗi cột.

- *Thời lượng (duration)* trung bình của các chuyến bay trong tập dữ liệu là 11,2 và thời lượng tối đa là 49,8 và thời lượng tối thiểu là 0,8.
- *Số ngày* trung bình *còn lại (days_left)* của các chuyến bay trong tập dữ liệu là 26 và số ngày còn lại tối đa là 49 và số ngày tối thiểu còn lại là 1.
- *Giá (price)* trung bình của các chuyến bay trong tập dữ liệu là 7425 và giá tối đa là 123071 và giá tối thiểu là 1105.
"""

# Check for missing values (null values) in the data using Pandas
pd.DataFrame({"Missing values (%)" : round(df.isnull().sum()/len(df), 2)})

# Check for nan values in the data using Pandas
pd.DataFrame({"N/A values (%)" : round(df.isna().sum()/len(df), 2)})

for i in df:
    print(i)
    print(df[i].unique(), "\n")

"""# TRỰC QUAN HOÁ DỮ LIỆU"""

# Look at the percentages between classes and the price differences.
plt.figure(figsize=(8,6))
df['class'].value_counts().plot(kind='pie',textprops={'color':'black'},autopct='%.2f')
plt.title('Classes of Different Airlines',fontsize=15)
plt.legend(['Economy','Business'])
plt.show()

plt.figure(figsize=(10,5))
sns.boxplot(x='class',y='price',data=df,palette='hls')
plt.title('Class Vs Ticket Price',fontsize=15)
plt.xlabel('Class',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

#  Displays economy class data
df_economy = df[df['class'] == 'Economy']
df_economy.head()

# Displays the number of flights between airlines and price comparisons.
plt.figure(figsize=(10,5))
sns.countplot(data=df_economy, x='airline', order=df_economy['airline'].value_counts().index[::-1])
plt.title('Flights Count of Different Airlines (Economy)', fontsize=15)
plt.xlabel('Airline', fontsize=15)
plt.ylabel('Count', fontsize=15)
plt.show()

plt.figure(figsize=(10,5))
sns.boxplot(data=df_economy, x='airline',y='price')
plt.title('Airlines Vs Price (Economy)',fontsize=15)
plt.xlabel('Airline',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

#  Displays business class data
df_business = df[df['class'] == 'Business']
df_business.head()

# Displays the number of flights between airlines and price comparisons.
plt.figure(figsize=(10,5))
sns.countplot(data=df_business, x='airline')
plt.title('Flights Count of Different Airlines (Business)',fontsize=15)
plt.xlabel('Airline',fontsize=15)
plt.ylabel('Count',fontsize=15)
plt.show()

plt.figure(figsize=(10,5))
sns.boxplot(data=df_business, x='airline',y='price')
plt.title('Airlines Vs Price (Business)',fontsize=15)
plt.xlabel('Airline',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

# Displays a price comparison between the number of stops
plt.figure(figsize=(10,5))
sns.boxplot(x='stops',y='price',data=df,palette='hls')
plt.title('Stops Vs Ticket Price',fontsize=15)
plt.xlabel('Stops',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

# Displays price comparison at departure time and arrival time
plt.figure(figsize=(10,5))
sns.boxplot(x='departure_time',y='price',data=df,palette='hls')
plt.title('Departure Time Vs Ticket Price',fontsize=15)
plt.xlabel('Departure Time',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

plt.figure(figsize=(10,5))
sns.boxplot(x='arrival_time',y='price',data=df,palette='hls')
plt.title('Arrival Time Vs Ticket Price',fontsize=15)
plt.xlabel('Arrival Time',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

# Displays a price comparison in the destination city and source city
plt.figure(figsize=(10,5))
sns.boxplot(x='source_city',y='price',data=df,palette='hls')
plt.title('Source City Vs Ticket Price',fontsize=15)
plt.xlabel('Source City',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

plt.figure(figsize=(10,5))
sns.boxplot(x='destination_city',y='price',data=df,palette='hls')
plt.title('Destination City Vs Ticket Price',fontsize=15)
plt.xlabel('Destination City',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

# Displays the number of flights of each route
total_combination = df.groupby(['source_city', 'destination_city']).agg(combination_count=('price', 'size'), avg_price=('price', 'mean')).reset_index()

total_combination['route_name'] = total_combination['source_city'].str[0] + total_combination['destination_city'].str[0]

total_combination = total_combination.sort_values(by='combination_count', ascending=False)

print(total_combination)

# Shows the effect of the number of flights on the price.
plt.figure(figsize=(10, 5))
sns.regplot(x='combination_count',y='avg_price',data=total_combination,color='cyan')
plt.title('Combination Count  Vs Average Price', fontsize=20)
plt.xlabel('Combination Count', fontsize=15)
plt.ylabel('Average Price', fontsize=15)
plt.show()

# Shows the effect of the duration of flights on the price.
plt.figure(figsize=(10, 5))
sns.regplot(x='duration', y='price', data=df, line_kws={'color': 'blue'})
plt.title('Duration  Vs Price', fontsize=20)
plt.xlabel('Duration', fontsize=15)
plt.ylabel('Price', fontsize=15)
plt.show()

# Shows the effect of the days left of flights on the price.
plt.figure(figsize=(10,5))
sns.lineplot(data=df,x='days_left',y='price',color='blue')
plt.title('Days Left Vs Price',fontsize=20)
plt.xlabel('Days Left',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

# Show the duration difference.
plt.figure(figsize=(10,5))
sns.kdeplot(data= df, x="duration")
plt.xlabel('Duration',fontsize=15)
plt.ylabel('Density',fontsize=15) #Tỉ trọng
plt.show()

"""- Thời lượng bị lệch phải và có đỉnh cao trong khoảng từ 0 đến 5, nghĩa là các chuyến bay kéo dài từ 0 đến 5 giờ là chuyến bay thường xuyên nhất"""

# Show the days_left difference.
plt.figure(figsize=(10,5))
sns.kdeplot(data= df, x="days_left")
plt.xlabel('Days_left',fontsize=15)
plt.ylabel('Density',fontsize=15) #Tỉ trọng
plt.show()

"""-	Days_left thường được phân phối với mức cao nhất từ 10 đến 40, cho thấy các chuyến bay hầu hết được bán khi số ngày còn lại nằm trong khoảng từ 10 đến 40."""

# Show the price difference.
plt.figure(figsize=(10,5))
sns.kdeplot(data= df, x="price")
plt.xlabel('Price',fontsize=15)
plt.ylabel('Density',fontsize=15) #Tỉ trọng
plt.show()

"""-	Giá lệch phải có mức cao nhất từ 0 đến 20.000, điều đó có nghĩa là các chuyến bay có giá nằm trong phạm vi này được bán thường xuyên"""

# Show significant price fluctuations when 1-2 days of departure remain.
filtered_data = df[df['days_left'].isin([1, 2])]

plt.figure(figsize=(10,5))
sns.pointplot(data=filtered_data, x='airline', y='price', hue='days_left')
plt.xlabel('Airline',fontsize=15)
plt.ylabel('Price',fontsize=15)
plt.show()

"""-	Giá tăng đáng kể khi còn 1 hoặc 2 ngày cho chuyến bay đặc biệt của hãng hàng không Vistara và Air India"""

# Show significant price fluctuations when 1-2 days of departure remain.
grouped_data = df.groupby (['departure_time','arrival_time'])['price'] .mean().sort_values(ascending=False)
plt.figure(figsize=(10,5))
grouped_data.plot(kind='bar')

plt.xlabel('Time',fontsize=15)
plt.show()

"""-	Khởi hành và đến vào ban đêm có giá thấp nhất tuy nhiên khởi hành vào ban đêm và đến vào buổi tối có giá cao nhất

# ĐÁNH GIÁ MÔ HÌNH

**Tính mức độ ảnh hưởng của từng cột đến giá.**
Chuyển các nhãn thành dạng số bằng Bộ mã hóa nhãn để có thể đọc được bằng hồi quy tuyến tính -> Tạo mô hình hồi quy tuyến tính
"""

from sklearn.preprocessing import LabelEncoder
import statsmodels.api as sm

# Coverting the labels into a numeric form using Label Encoder so that it can be read by linear regression
le=LabelEncoder()
for col in df.columns:
    if df[col].dtype=='object':
        df[col]=le.fit_transform(df[col])

# Create a linear regression model
X = df.drop('price', axis=1)
X = sm.add_constant(X)
y = df['price']

lin_reg = sm.OLS(y, X).fit()

print(lin_reg.summary())

"""*=> Từ kết quả chúng ta có thể thấy rằng mỗi cột đều có ảnh hưởng đáng kể đến giá cả.*

**Tìm mô hình tốt nhất cho dữ liệu**
"""

import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor, ExtraTreesRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import MinMaxScaler

# Separating data into train and test
X=df.drop(['price'],axis=1)
y=df['price']

# Splitting the Data into Training set and Testing Set
from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=0.30,random_state=42)

# Scaling the values to convert the int values to Machine Languages
mmscaler=MinMaxScaler(feature_range=(0,1))
x_train=mmscaler.fit_transform(X_train)
x_test=mmscaler.fit_transform(X_test)
x_train=pd.DataFrame(x_train)
x_test=pd.DataFrame(x_test)

# Model initialization
rf_model = RandomForestRegressor()
et_model = ExtraTreesRegressor()
dt_model = DecisionTreeRegressor()
ln_model = LinearRegression()

# Fitting models to train data
rf_model.fit(X_train, y_train)
et_model.fit(X_train, y_train)
dt_model.fit(X_train, y_train)
ln_model.fit(X_train, y_train)

# Make predictions on test data
rf_pred = rf_model.predict(X_test)
et_pred = et_model.predict(X_test)
dt_pred = dt_model.predict(X_test)
ln_pred = ln_model.predict(X_test)

# Model evaluation
def evaluate_model(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    mse = mean_squared_error(y_true, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_true, y_pred)
    rmsle = np.sqrt(np.mean(np.log1p(np.square(np.log1p(y_pred) - np.log1p(y_true)))))
    mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100

    return mae, mse, rmse, r2, rmsle, mape

"""**MAE (Mean Absolute Error):** Đo lường sự chênh lệch trung bình giữa giá trị dự đoán và giá trị thực tế. Giá trị càng thấp càng tốt, vì nó chỉ tính giá trị tuyệt đối của sai số mà không quan tâm đến hướng.

**MSE (Mean Squared Error):** Đo lường sự chênh lệch bình phương trung bình giữa giá trị dự đoán và giá trị thực tế. Nó có xu hướng đặt trọng số lớn hơn cho các sai số lớn. Giá trị MSE cao thường cho thấy mô hình đang mắc phải các dự đoán lớn.

**RMSE (Root Mean Squared Error):** Là căn bậc hai của MSE, giúp đưa ra đánh giá về sự chênh lệch trung bình giữa giá trị dự đoán và giá trị thực tế. RMSE cũng giúp mô hình tránh được ảnh hưởng của các sai số lớn.

**R-squared (R2):** Đo độ giải thích của mô hình đối với phương sai của dữ liệu. Giá trị R2 gần 1 cho thấy mô hình giải thích được một phần lớn sự biến động của dữ liệu.

**RMSLE (Root Mean Squared Logarithmic Error):** Là biến thể của RMSE được áp dụng trên logarit của giá trị dự đoán và giá trị thực tế. Thường được sử dụng khi dự đoán dữ liệu có phạm vi rộng và có ý nghĩa khi các sai số nhỏ quan trọng hơn các sai số lớn.

**MAPE (Mean Absolute Percentage Error):** Đo lường tỷ lệ phần trăm trung bình giữa giá trị tuyệt đối của sự chênh lệch và giá trị thực tế. Giá trị càng thấp cho thấy mức độ chính xác của mô hình, nhưng nó cũng có thể bị ảnh hưởng bởi giá trị thực tế gần
"""

# Evaluate each model

rf_eval = evaluate_model(y_test, rf_pred)
print("RandomForestRegressor Evaluation:")
print(f"MAE: {rf_eval[0]:.2f}")
print(f"MSE: {rf_eval[1]:.2f}")
print(f"RMSE: {rf_eval[2]:.2f}")
print(f"R^2: {rf_eval[3]:.4f}")
print(f"RMSLE: {rf_eval[4]:.2f}")
print(f"MAPE: {rf_eval[5]:.2f}%\n")

et_eval = evaluate_model(y_test, et_pred)
print("ExtraTreesRegressor Evaluation:")
print(f"MAE: {et_eval[0]:.2f}")
print(f"MSE: {et_eval[1]:.2f}")
print(f"RMSE: {et_eval[2]:.2f}")
print(f"R^2: {et_eval[3]:.4f}")
print(f"RMSLE: {et_eval[4]:.2f}")
print(f"MAPE: {et_eval[5]:.2f}%\n")

dt_eval = evaluate_model(y_test, dt_pred)
print("DecisionTreeRegressor Evaluation:")
print(f"MAE: {dt_eval[0]:.2f}")
print(f"MSE: {dt_eval[1]:.2f}")
print(f"RMSE: {dt_eval[2]:.2f}")
print(f"R^2: {dt_eval[3]:.4f}")
print(f"RMSLE: {dt_eval[4]:.2f}")
print(f"MAPE: {dt_eval[5]:.2f}%\n")

ln_eval = evaluate_model(y_test, ln_pred)
print("LinearRegression Evaluation:")
print(f"MAE: {ln_eval[0]:.2f}")
print(f"MSE: {ln_eval[1]:.2f}")
print(f"RMSE: {ln_eval[2]:.2f}")
print(f"R^2: {ln_eval[3]:.4f}")
print(f"RMSLE: {ln_eval[4]:.2f}")
print(f"MAPE: {ln_eval[5]:.2f}%\n")

"""**Phân tích đánh giá số liệu từ các mô hình RandomForestRegressor, ExtraTreesRegressor, DecisionTreeRegressor, và LinearRegression:**

***RandomForestRegressor:***

*MAE (Mean Absolute Error):* 893.84 - Độ lệch trung bình giữa giá trị dự đoán và giá trị thực tế là khá thấp, cho thấy mô hình có hiệu suất tốt trong việc dự đoán giá vé.

*RMSE (Root Mean Squared Error):* 2373.20 - Giá trị này cũng thấp, chỉ ra mức độ chênh lệch trung bình giữa dự đoán và thực tế.

*R^2 (R-squared):* 0.9891 - Gần 1, đây là một độ đo tốt về khả năng giải thích của mô hình đối với phương sai của dữ liệu.

*RMSLE (Root Mean Squared Logarithmic Error):* 0.12 - Giảm thiểu sự chênh lệch giữa giá trị dự đoán và giá trị thực tế khi dữ liệu có phạm vi rộng.

*MAPE (Mean Absolute Percentage Error):* 6.01% - Tỉ lệ phần trăm trung bình giữa sự chênh lệch và giá trị thực tế là khá thấp.

***ExtraTreesRegressor:***

Đánh giá tương tự với RandomForestRegressor, với mức độ chính xác và hiệu suất dự đoán khá cao.

***DecisionTreeRegressor:***

Hiệu suất dự đoán tương đối tốt, nhưng có vẻ dưới RandomForestRegressor và ExtraTreesRegressor.

***LinearRegression:***

*MAE:* 4623.41 - Độ lệch trung bình lớn hơn so với các mô hình DecisionTreeRegressor, cho thấy Linear Regression không phù hợp cho dự đoán giá vé chuyến bay trong trường hợp này.

*R^2:* 0.9047 - R^2 thấp hơn so với các mô hình DecisionTreeRegressor, chỉ ra rằng mô hình không giải thích được mức độ phương sai của dữ liệu như các mô hình cây quyết định.

**Tổng quan:**
Cả RandomForestRegressor và ExtraTreesRegressor đều có hiệu suất cao, với độ chính xác và khả năng dự đoán tốt.
DecisionTreeRegressor cũng cho kết quả tốt nhưng có vẻ dưới mức của các mô hình cây tổ hợp.
LinearRegression không phù hợp cho dự đoán giá vé trong trường hợp này, có thể do tính phi tuyến của dữ liệu.

# **RANDOM FOREST REGRESSOR**
"""

#Training the model with RandomForestRegressor
rf_model.fit(X_train, y_train)

# Predict the model with test data
y_pred = rf_model.predict(X_test)

out_rf=pd.DataFrame({'Price_actual':y_test,'Price_pred':y_pred})
result_rf = df_1.merge(out_rf,left_index=True,right_index=True)
result_rf.sample(20)

# Display the graphic between actual price and prediction price.
plt.figure(figsize=(10,5))
sns.regplot(x='Price_actual',y='Price_pred',data=result_rf)
plt.title('Actual Price  Vs  Predicted Price (RandomForest) ',fontsize=20)
plt.xlabel('Actual Price',fontsize=15)
plt.ylabel('Predicted Price',fontsize=15)
plt.show()

# Calculates the percentage of equal values
matching_values = (result_rf['Price_actual'] == result_rf['Price_pred']).sum()
total_rows = len(result_rf)
percentage_matching = (matching_values / total_rows) * 100
print(f'The percentage of the same value: {percentage_matching:.2f}%')

# Calculate the percentage of values ​​where the price difference is not more than 500
within_500_diff = abs(result_rf['Price_pred'] - result_rf['Price_actual']) <= 500
matching_within_500 = within_500_diff.sum()
total_rows = len(result_rf)
percentage_within_500 = (matching_within_500 / total_rows) * 100
print(f'Price percentage with a difference of no more than 500: {percentage_within_500:.2f}%')

"""# LINEAR REGRESSOR"""

#Trainig the model with
ln_model.fit(X_train, y_train)
# Predict the model with test data
y_pred = ln_model.predict(X_test)
out_ln=pd.DataFrame({'Price_actual':y_test,'Price_pred':y_pred})
result_ln = df_1.merge(out_ln,left_index=True,right_index=True)

result_ln.sample(20)

# Display the graphic between actual price and prediction price.
plt.figure(figsize=(10,5))
sns.regplot(x='Price_actual',y='Price_pred',data=result_ln)
plt.title('Actual Price  Vs  Predicted Price (LinearRegression) ',fontsize=20)
plt.xlabel('Actual Price',fontsize=15)
plt.ylabel('Predicted Price',fontsize=15)
plt.show()

# Calculates the percentage of equal values
matching_values = (result_ln['Price_actual'] == result_ln['Price_pred']).sum()
total_rows = len(result_ln)
percentage_matching = (matching_values / total_rows) * 100
print(f'The percentage of the same value: {percentage_matching:.2f}%')

# Calculate the percentage of values ​​where the price difference is not more than 500
within_500_diff = abs(result_ln['Price_pred'] - result_ln['Price_actual']) <= 500
matching_within_500 = within_500_diff.sum()
total_rows = len(result_ln)
percentage_within_500 = (matching_within_500 / total_rows) * 100
print(f'Price percentage with a difference of no more than 500: {percentage_within_500:.2f}%')

"""# EXTRA TREES REGRESSOR"""

#Trainig the model with ExtraTreesRegressor
et_model.fit(X_train, y_train)
# Predict the model with test data
y_pred = et_model.predict(X_test)
out_et=pd.DataFrame({'Price_actual':y_test,'Price_pred':y_pred})
result_et = df_1.merge(out_et,left_index=True,right_index=True)

result_et.sample(20)

# Display the graphic between actual price and prediction price.
plt.figure(figsize=(10,5))
sns.regplot(x='Price_actual',y='Price_pred',data=result_et)
plt.title('Actual Price  Vs  Predicted Price (ExtraTrees) ',fontsize=20)
plt.xlabel('Actual Price',fontsize=15)
plt.ylabel('Predicted Price',fontsize=15)
plt.show()

# Calculates the percentage of equal values
matching_values = (result_et['Price_actual'] == result_et['Price_pred']).sum()
total_rows = len(result_et)
percentage_matching = (matching_values / total_rows) * 100
print(f'The percentage of the same value: {percentage_matching:.2f}%')

# Calculate the percentage of values ​​where the price difference is not more than 500
within_500_diff = abs(result_et['Price_pred'] - result_et['Price_actual']) <= 500
matching_within_500 = within_500_diff.sum()
total_rows = len(result_et)
percentage_within_500 = (matching_within_500 / total_rows) * 100
print(f'Price percentage with a difference of no more than 500: {percentage_within_500:.2f}%')

"""# DECISION TREE REGRESSOR"""

#Trainig the model with Decision Tree Regressor
dt_model.fit(X_train, y_train)
# Predict the model with test data
y_pred = dt_model.predict(X_test)
out_dt=pd.DataFrame({'Price_actual':y_test,'Price_pred':y_pred})
result_dt = df_1.merge(out_dt,left_index=True,right_index=True)

result_dt.sample(20)

# Display the graphic between actual price and prediction price.
plt.figure(figsize=(10,5))
sns.regplot(x='Price_actual',y='Price_pred',data=result_dt)
plt.title('Actual Price  Vs  Predicted Price (DecisionTree) ',fontsize=20)
plt.xlabel('Actual Price',fontsize=15)
plt.ylabel('Predicted Price',fontsize=15)
plt.show()

# Calculates the percentage of equal values
matching_values = (result_dt['Price_actual'] == result_dt['Price_pred']).sum()
total_rows = len(result_dt)
percentage_matching = (matching_values / total_rows) * 100
print(f'The percentage of the same value: {percentage_matching:.2f}%')

# Calculate the percentage of values ​​where the price difference is not more than 500
within_500_diff = abs(result_dt['Price_pred'] - result_dt['Price_actual']) <= 500
matching_within_500 = within_500_diff.sum()
total_rows = len(result_dt)
percentage_within_500 = (matching_within_500 / total_rows) * 100
print(f'Price percentage with a difference of no more than 500: {percentage_within_500:.2f}%')

"""Từ các phản hồi và đánh giá được thu thập, có thể kết luận rằng mô hình **RandomForestRegressor** là chính xác nhất trong bài toán dự đoán giá vé chuyến bay. Sự kết hợp của nhiều cây quyết định độc lập, khả năng tự động hóa quyết định, và khả năng chống *overfitting* đã giúp mô hình này đạt được hiệu suất ấn tượng trên nhiều tập dữ liệu và điều kiện thử nghiệm. Điều này làm cho **RandomForestRegressor** trở thành sự lựa chọn lý tưởng cho ứng dụng dự đoán giá vé chuyến bay, mang lại sự chính xác và độ tin cậy trong dự báo giá trị."""